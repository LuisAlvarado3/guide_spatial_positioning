<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modelo de posicionamiento espacial</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/css/style.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduccion.html"><strong aria-hidden="true">1.</strong> Introducción                             </a></li><li class="chapter-item expanded "><a href="cap1/0_cap1.html"><strong aria-hidden="true">2.</strong> Capitulo 1                               </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap1/1_sis_ref.html"><strong aria-hidden="true">2.1.</strong> Sistema de Referencia                </a></li><li class="chapter-item expanded "><a href="cap1/2_prim_s_ref.html"><strong aria-hidden="true">2.2.</strong> Primitivas de sistemas de referencia </a></li><li class="chapter-item expanded "><a href="cap1/3_conv_sis_ref.html"><strong aria-hidden="true">2.3.</strong> Conversión de sistema de referencia  </a></li><li class="chapter-item expanded "><a href="cap1/4_algoritmo.html"><strong aria-hidden="true">2.4.</strong> Algoritmo                            </a></li><li class="chapter-item expanded "><a href="cap1/5_python.html"><strong aria-hidden="true">2.5.</strong> Implementación en Python             </a></li><li class="chapter-item expanded "><a href="cap1/6_js.html"><strong aria-hidden="true">2.6.</strong> Implementación en JavaScript         </a></li></ol></li><li class="chapter-item expanded "><a href="cap2/0_cap2.html"><strong aria-hidden="true">3.</strong> Capítulo 2                               </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap2/1_traslacion.html"><strong aria-hidden="true">3.1.</strong> Traslación                           </a></li></ol></li><li class="chapter-item expanded "><a href="cap3/0_cap3.html"><strong aria-hidden="true">4.</strong> Capítulo 3                               </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cap3/1_rotacion.html"><strong aria-hidden="true">4.1.</strong> Rotación                             </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modelo de posicionamiento espacial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<p>Esta pequeña guia pretende ejemplificar algunas de las herramientas para modelos de posicionamiento espacial utilizando matrices de rotación y traslación para posteriormente implementarlo en un programa diseñado en <code>python</code>.</p>
<p>Dicho proyecto final estará disponible para el uso práctico que desee aplicar, y esta guía comprendera los fines de su realización para elaborarlo en un lenguaje de programación.</p>
<p>Como en muchos casos, no me agrada tánto la idea de tener que conseguir tantas dependencias para escribir un programa, por lo que mi intención en este recuento es que se logre realizar integramente con la minima cantidad de dependencias el programa, siendo que solo dependa de las herramientas nativas que proporcione el lenguaje de programación y a lo mucho una que otra externa.</p>
<p>Aunque no me encuentro tan familiarizado con la interpretación matemática me esforzaré por que sea primeramente comprensible, simple y autoexplicativa para que se logre reconocer por la mayoria de lectores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capitulo-1-sistema-de-referencia"><a class="header" href="#capitulo-1-sistema-de-referencia">Capitulo 1: Sistema de referencia.</a></h1>
<h2 id="introducción-1"><a class="header" href="#introducción-1">Introducción.</a></h2>
<p>Cuando necesitamos identificar la ubicación de algún lugar u objeto siempre requerimos de un marco de referencia, por ejempo para llegar a determinada calle tienes que seguir ciertas indicacioes como seguir 4 cuadras a la derecha junto al centro comercial o camina unos 100 metros en línea recta hasta llegar al cruce de la calle principal; sin embargo si usasemos este tipo de indicaciones estamos siendo poco precisos, por ello nosotros requerimos usar ciertas reglas y notación numérica para conseguir llegar al punto deseado, y como deseamos compararlo con un regimen real es que necesitamos indicarle mediante los números reales en donde estamos, el símbolo matemático para representar a los números reales que utilizaremos es \(\mathbb{R}\), nosotros representamos el desplazamiento o ubicación de un objeto u punto mediante una recta (generalmente horizontal) con notación real:</p>
<ul>
<li>Recta numérica: Se trata de una línea (generalmente horizontal) donde la distancia se representa mediante puntos, enmarcada por un origen al que se le denomina como \(O\) (se lee origen); en el centro de la recta se encuentra \(O\) y el valor de la posición para cualquier cosa en \(O\) vale \(0\). Si sobre la recta desplazaramos un punto a la derecha del origen de \(O\) entonces el desplazamiento es positivo (o decimos que nos alejamos del origen en el eje positivo), por el contrario, si desplazamos un punto a la izquierda de \(O\) entonces incrementara la posición en valores negativos (nos alejamos de \(O\) en el eje negativo).</li>
</ul>
<p><img src="cap1/./imgs/rectax.jpg" alt="" /></p>
<ul>
<li>Eje: un eje es un marco de referencia sobre el cual nosotros posicionamos o desplazamos un objeto, en el caso anterior, le atribuimos el nombre de este eje como \(x\) (se lee, eje \(x\), indistíntamente si estamos en el ámbito negativo o positivo).</li>
</ul>
<p>Si bien hasta el momento explique como podríamos representar la ubicación en un solo marco de referencia (eje), en el mundo real nosotros reconocemos intuitivamente más de uno, y dependiendo de como abstremos esta información de la percepción del mundo real es que los nombramos, esto es lo que conocemos como sistema de referencia. Este capítulo tiene como intención denotar e interpretar los sistemas de referencia.</p>
<p>Al finalizar este capítulo usted debería saber los siguientes aspectos:</p>
<ul>
<li>Comprenderá algunas notaciónes matemáticas.</li>
<li>Conocerá los distíntos tipos de sistemas de referencia.</li>
<li>Describirá la posición de un punto según el sistema de referencia.</li>
<li>Interpretará y diseñará un algorítmo para convertir la posición de un objeto a alguno de los sistemas de referencia escritos en este capítulo.</li>
<li>Escribirá un programa para convertír un sistema de referencia a otro con el algoritmo utilizado.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sistema-de-referencia"><a class="header" href="#sistema-de-referencia">Sistema de Referencia.</a></h1>
<p>Un sistema de referencia es como su nombre lo dice, es un sistema con el que obtenemos una visión ideal espacial para representar nuestro entorno o parte de ella. La finalidad es identificar elementos en ese espacio numéricamente obteniendo información de ella como lo es la posición, el tiempo, la velocidad, etc.</p>
<p>Algunos de los sistemas de referencia se podrían clasificar según el tipo de ejes, tal como:</p>
<p>Unidimensional (\(\mathbb{R}^1\)):</p>
<ul>
<li>Recta numérica.</li>
</ul>
<p>Bidimensional (\(\mathbb{R}^2\)):</p>
<ul>
<li>Coordenadas Cartesianas.</li>
<li>Coordenadas Polares.</li>
</ul>
<p>Tridimensional (\(\mathbb{R}^3\)):</p>
<ul>
<li>Coordenadas Cartesianas.</li>
<li>Coordenadas Cilíndricas.</li>
<li>Coordenadas Esféricas.</li>
</ul>
<blockquote>
<p>Nota: Utilizo el símbolo \(\mathbb{R}\) donde su exponenete representa el número de dimensiones que tiene el sistema. Así, si un sistema tiene dos dimensiones utilizaré \(\mathbb{R}^2\), un sistema de tres dimensiones es \(\mathbb{R}^3\).
O dicho de otra forma, sea un sistema de \(n\) dimensiones representado por un espacio de números reales (\(\mathbb{R}\)), entonces el sistema \(n-dimensional\) está dado por la expresión:
$$
\mathbb{R}^n
$$</p>
</blockquote>
<h2 id="sistema-unidimensional"><a class="header" href="#sistema-unidimensional">Sistema Unidimensional...</a></h2>
<h3 id="recta-numérica"><a class="header" href="#recta-numérica">Recta numérica...</a></h3>
<h2 id="sistema-bidimensional"><a class="header" href="#sistema-bidimensional">Sistema Bidimensional.</a></h2>
<h3 id="coordenadas-cartesianas-en-dos-dimensiones"><a class="header" href="#coordenadas-cartesianas-en-dos-dimensiones">Coordenadas Cartesianas en dos dimensiones.</a></h3>
<p>También conocido como <strong>Sistema Cartesiano Rectangular</strong> o <strong>Sistema Coordenado Rectangular</strong> es sugerido como un plano que consta de dos rectas numéricas que, perpendicularmente se intersecan, por ende comparten un punto al que se le denomina origen y se representa por \(O\). El valor del origen en cada recta es de \(0\) ya que es el punto de referencia para representar la posición de algo.</p>
<blockquote>
<p>Nota: <a href="https://dle.rae.es/intersecar">Intersecar</a> es un término que se utiliza para indicar que dos líneas, superficies o sólidos se cortan, o se dice que se cruzan.</p>
</blockquote>
<p>Como ya se ha mencionado, el <strong>Sistema Cartesiano Rectangular</strong> se conforma por dos rectas; la primér recta, o recta horizontal, también denominada como eje \(X\), se enumera en rango positivo desde el origen \(O\) hacia la derecha y se enumera en rango negativo desde \(O\) hacia la izquierda; la segunda recta es una recta vertical y es conocida como eje \(Y\), su rango positivo se encuentra desde el origen \(O\) hacia arriba, y el rango negativo desde el \(O\) hacia abajo.</p>
<p>Entonces un plano bidimensional (cartesiano), es un sistema coordenado asociado por los dos ejes y es expresado como \(OXY\).</p>
<p>Definición: <em>Sea un <em><strong>plano bidimensional</strong></em> \(\mathbb{R}^2\) conocido como el conjunto de parejas ordenadas de números reales</em>, como:
$$
\mathbb{R}^2 = \{ (X, Y) | X, Y \in \mathbb{R} \}
$$</p>
<blockquote>
<p>Nota: <br>
Corchetes &quot;\(\{\}\)&quot;: o también conocido como llaves (\(\{\}\)) se utilizan para indicar que se trata de un conjunto de algo. Todos los elementos que pertenecen al conjunto se encierran entre las llaves, por ejemplo, el conjunto de números del \(0\) al \(10\) puede ser expresado como: 
$$\{ 0,1,2,3,...,9,10 \} $$
y se lee como (el conjunto del 0 al 10, por ejemplo).<br><br>
Expresión &quot;\(|\)&quot;: Utilizada en conjuntos, denominada <em>notación constructora de conjuntos</em> sirve para denotar una condición bajo la cual se está dando un dominio en los elementos. Tambien es equivalente a &quot;\(:\)&quot;, y siempre (o en este caso) se utiliza colocando los elementos seguida de la expresión \(|\) y despues la condicionante, por ejemplo el conjunto de todos los valores para \(x\) en los que su dominio es positivo y mayor a cero podría ser:
$$
\{ x | x&gt;0 \}
$$
y se lee como (el conjunto de x tal que x mayor a 0)<br><br>
Expresión &quot;\(\in\)&quot;: Utilizada en expresiones con parámetros de pertenencia, conocida como <em>membresia de conjuntos de pertenencia</em> se utiliza para indicar que cierto elemento pertenece a determinada cosa. Por ejemplo, podemos decir que 7 pertenece a los números natuarales \(\mathbb{N}\), en tal caso se representa de la siguiente forma:
$$
7 \in \mathbb{N}
$$
y se lee como, (siete pertenece a los números naturales).</p>
</blockquote>
<h3 id="coordenadas-polares"><a class="header" href="#coordenadas-polares">Coordenadas Polares</a></h3>
<p>En un plano \(\mathbb{R}^2\) representado por un sistema polar se centra principalmente en la localización de objetos utilizando pares coordenados de magnitud y dirección, mediante un segmento y un ángulo; donde el segmento es conocido como <strong>radio polar</strong> y al ángulo como <strong>ángulo polar</strong>.</p>
<blockquote>
<p>Nota: El radio polar también es conocido como <strong>radio vector</strong> y el angulo polar se le suele decir tambien como <strong>ángulo argumento</strong>, Sin embargo queda mejor descrito que la posición en un sistema polar se defina al nombre coordenado implícitamente.</p>
</blockquote>
<p>El plano polar queda descrito por un origen denominado Polo (\(O\)) y tambien se caracteriza por poder representarse mediante un eje horizontal \(X\)  y uno vertical  \(Y\), sin embargo la forma de representarse es con un eje:
$$
X=\{x | x \in \mathbb{R}\}
$$
y un semieje angular \(O\Theta\), donde \(\Theta\) es el eje angular:
$$
\Theta=\{ \theta | \theta \in \mathbb{R}\sphericalangle \}
$$</p>
<p>Entonces el plano bidimensional (polar), es un sistema coordenado asociado por los dos ejes y es expresados como \(OX\Theta\).</p>
<p>Definición: <em>Sea un <strong>plano bidimensional</strong> \(\mathbb{R}^2\) conocido como el conjunto de parejas ordenadas por números reales, y una representación angular</em>, como:
$$
\mathbb{R}^2=\{ (X, \Theta) | X,\Theta \in \mathbb{R}, \Theta \in \sphericalangle \}
$$</p>
<blockquote>
<p>Nota: <br>
Letra \(\theta\) y \(\Theta\):  Es una letra del alfabeto griego y se lee como (theta), en particular utilizaré esta letra como una representación simbólica de un número angular.<br><br>
Simbolo \(\sphericalangle\): No he profundizado en su utilización, sin embargo, por el momento lo utilizaré para identificar que se trata de un conjunto de números angulares.</p>
</blockquote>
<h2 id="sistema-tridimensional"><a class="header" href="#sistema-tridimensional">Sistema Tridimensional.</a></h2>
<h3 id="coordenadas-cartesianas-tridimensionales"><a class="header" href="#coordenadas-cartesianas-tridimensionales">Coordenadas Cartesianas Tridimensionales.</a></h3>
<p>El sistema cartesiano tridimensional, cuenta con tres rectas perpendiculares entre si, denominados ejes \(X\), \(Y\) y \(Z\) además de un origen \(O\) generado por intersecarse los tres ejes. Por lo tanto, el sistema cartesiano se representa como \(OXYZ\).</p>
<p>Sea <strong>un plano tridimensional</strong> \(\mathbb{R}^3\) conocido como una terna ordenada de números reales, como:
$$
\mathbb{R}^3 = \{(X,Y,Z) | X, Y, Z \in \mathbb{R} \}
$$</p>
<h3 id="coordenadas-cilíndricas"><a class="header" href="#coordenadas-cilíndricas">Coordenadas Cilíndricas...()</a></h3>
<p>Sean \((r, \theta)\) las coordenadas polares en el plano \(\Pi\) determinadas por el polo \(O\) y el eje polar \(OA\).</p>
<p>Para cada punto \(M \in \mathbb{R}^3 \ OZ\) sea \(M'\) la proyección de \(M\) sobre el plano \(\Pi\). Entonces, las <em>coordenadas cilíndricas</em> del punto \(M\) son la terna ordenada \((r, \theta, z)\) donde \((r, \theta)\) son las coordenadas polares del punto \(M'\) en el plano \(\Pi\) y \(z\) es la longitud del segmento orientado \(MM'\). Por definición,</p>
<h3 id="coordenadas-esféricas"><a class="header" href="#coordenadas-esféricas">Coordenadas Esféricas...()</a></h3>
<p>Sea \(O\) un punto en el espacio \(\mathbb{R}^3\) y fijamos una recta orientada \(OZ\) que pasa por \(O\) y un semiplano \(\alpha\) pasando por \(OZ\). Además tomemos el plano \(\pi\) que pasa por \(O\) y ortogonal al rayo \(OZ\). Para cada punto \(M\) que pertenece a la recta \(OZ\), sea \(M'\) la proyección de \(M\) sobre el plano \(\Pi\). Entonces el punto \(M\) tiene por <em>coordenadas esféricas</em> la terna \((\rho, \phi, \theta)\) donde \(\rho = |OM|\), \(\phi\) es el ángulo entre la dirección positiva \(OZ\) y el vector \(OM (0 &lt; \phi &lt; \pi)\), y \(\theta\) es el ángulo polar de \(M'\) en el plano \(\Pi\), donde \(0 &lt; \theta &lt; 2\pi\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitivas-de-sistemas-de-referencia"><a class="header" href="#primitivas-de-sistemas-de-referencia">Primitivas de sistemas de referencia</a></h1>
<p>Ahora bien, si ya hemos descrito los distíntos sistemas de referencia, lo siguiente es expresar los objetos en el.</p>
<p>Lo primero que debemos conocer antes de conformar un objeto muy complejo es conocer los sigueintes objetos primitivos:</p>
<ul>
<li>
<p>Punto: Es un objeto idoneo para representar una posición en el espacio y que no tiene una dimensión en especial. <br>
Sea un punto identificado como \(a\) conformado por las componenetes \((x,y)\) y corresponden a los ejes coordenados del sistema \(OXY\). La componente puede estar dada por un valor numérico, y este valor \(x\) se encuentra en la recta \(X\); y su contraparte, la componete \(y\) se encuentra en algún lugar de \(Y\).</p>
</li>
<li>
<p>Recta: ...()</p>
</li>
<li>
<p>Rayo: ...()</p>
</li>
<li>
<p>Vector: Es un objeto utilizado para indicar una cantidad, tal primitiva tiene tiene tanto una magnitud como una dirección, es decir, a diferencia del punto, un vector apunta hacia algún lado (por ejemplo un punto). Gráficamente el vector es representado por un segmento de recta dirigido por una flecha, donde la longitud del segmento es la magnitud y la flecha la dirección a la que apunta. La expresión que denota a un vector es por lo general una letra en negrita o también puede ser una letra con una flecha en la parte posteriór de ella. <br>
Un vector de desplazamiento \(\vec{v}\) es un elemento enmarcado por un punto \(A\) al que denominaremos como la cola dirigido hacia un punto \(B\) que es donde termina el vector y será la punta del vector, entonces el vector es de la forma:
$$
\vec{v} = \vec{AB}
$$</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversión-de-sistema-de-referencia"><a class="header" href="#conversión-de-sistema-de-referencia">Conversión de sistema de referencia.</a></h1>
<p>De acuerdo a como se señaló en el capítulo <a href="cap1/./1_sis_ref.html">Sistemas de Referencia</a>, algunas de las diferentes coordenadas que existen para representar un elemento (objeto) fueron definidas muy resumidamente. Sin embargo algo que se puede reconocer es que cada uno de estos sistemas es que toman una relación íntima, estas son sus componentes. En este apartado mostraré una forma de pasar de un sistema coordenado a otro con la finalidad de comprender la relación que abordan cada uno de ellos.</p>
<blockquote>
<p>Nota: Puedes tener un exceso de información con respecto de un sistema \(\mathbb{R}^2\) que es convertido a un sistema \(\mathbb{R}^3\), sin embargo es importante saber que ocurre lo contrario de un sistema de \(\mathbb{R}^3\) hacia un sistema \(\mathbb{R}^2\) en tal caso puede que los datos no sean recuperados a como eran en un principio y es mejor tratar este tipo de conversión con cautela.</p>
</blockquote>
<blockquote>
<p><strong>Dominio del ángulo a través de la función tangente</strong>: <br />
Para cualquier ángulo obtenido mediante la <strong>tangente</strong> es posible que se tenga que apegar a ciertas condiciones para obtener el valor deseado, no solo basta con enviar la instrucción matemática en la calculadora, sino que requiere de ciertas nociones para determinar el ángulo en la dirección correcta. Para cualquier ángulo descrito en el plano cartesiano, recordar que la función <strong>tangente</strong> funciona en realción a los lados de un triángulo rectángulo, por lo que es importante identificar el dominio en el que se encuentra el tríangulo rectangulo en el plano cartesiano. <br />
<img src="cap1/../imgs/quadrants.jpg" alt="" /> <br />
En la imagen de arriba se ha dividido el plano cartesiano en 4 secciones a las que se les denomina cuadrantes y se enumeran en números (de preferencia) romanos y sentido antihorario, además de ello se han colocado 4 triángulos indicando el sentido en el que se describen los valores de sus ángulos.
La función que expresa la relación del ángulo con respecto de los catetos opuestos y adyacentes es:
$$
\tan{\alpha} = \frac{opuesto}{adyacente}
$$
Y la expresión para obtener el ángulo es:
$$
\alpha = \arctan{\frac{opuesto}{adyacente}}
$$
La igualdad se cumple siempre que el cateto adyacente sea distinto de cero por lo cual, la primera norma válida para la función es: <br />
I. Para \(adyacente \neq 0\) entonces \(\alpha\) existe, de otra forma \(\alpha\) no está definido. <br />
Si tanto el <strong>cateto opuesto</strong> como el <strong>adyacente</strong> son iguales a cero, entonces eso quiere decír que no hay un ángulo, por lo que, <br />
II. Si \(x,y = 0\) entonces \(\alpha = 0°\). <br />
Si <strong>cateto adyacente</strong> es mayor a cero y <strong>cateto opuesto</strong> es igual a cero entonces el ángulo es igual a cero. Caso inverso sucede que \(\alpha\) es un ángulo recto. <br />
III. Si \(adyacente&gt;0\) y \(opuesto=0\) entonces \(\alpha=0°\). <br />
IV. Si \(opuesto&gt;0\) y \(adyacente=0\) eontonces \(\alpha=90°\). <br />
Los siguientes casos indican que se debe hacer en caso de que los catetos sean menores a cero. <br />
V. Si \(adyacente&lt;0\) pero \(opuesto\) es positivo, entonces se encuentra en el segundo cuadrante del plano y el ángulo resultante es horario, entonces para el ángulo \(\alpha\):
$$
\alpha = 180 + \arctan{ \frac{opuesto}{adyacente} }
$$
VI. Si \(adyacente, opuesto&lt; 0\) entonces el ángulo se encuentra en el tercer cuadrante y el ángulo es antihorario:
$$
\alpha = 270 - \arctan{ \frac{opuesto}{adyacente} }
$$
VII. Si \(opuesto&lt;0\) pero \(adyacente\) es positivo, entonces se encuentra en el cuarto cuadrante del plano y el ángulo resultante es horario, entonces para el ángulo \(\alpha\):
$$
\alpha = 360 + \arctan{ \frac{opuesto}{adyacente} }
$$
Estas propociciones se utilizarán en la sección <a href="cap1/4_algoritmo.html">Algorítmo</a> y posteriores.</p>
</blockquote>
<h2 id="sistemas-bidimensionales"><a class="header" href="#sistemas-bidimensionales">Sistemas Bidimensionales.</a></h2>
<h3 id="coordenadas-cartesianas-polares"><a class="header" href="#coordenadas-cartesianas-polares">Coordenadas Cartesianas-Polares.</a></h3>
<p>Para una coordenada cartesiana, se verifican los valores para las dos componenetes  en el punto \(p\) donde sus compoenetes son \((x,y)\), y están dadas por por las siguientes ecuaciones:
$$
x = r *\cos{\theta}
$$
$$
y = r *\sin{\theta}
$$
De forma relevante se puede expresar en terminos para cualquiera de las dos ecuaciones anteriores que:
$$
\frac{x}{r} = \cos{\theta}\\
\frac{y}{r} = \sin{\theta}
$$ o bien que,
$$
\frac{y}{x} = \tan{\theta}
$$
Para encontrar el <strong>radio polar</strong> \(\vec{r}\) es necesario convertir nuestro par de componentes \((x,y)\) a nuevo vector utilizando el <strong>teorema de pitágoras</strong>, el cual nos dice que, sea un triángulo rectángulo, la suma de dos de sus lados cada una al cuadrado es igual al tercero al cuadrado:
$$
c^2 = a^2+b^2
$$
Dado que \(x\) y \(y\) representan los catetos para la <strong>coordenada</strong>, entonces asumiremos la siguiente igualdad:
$$
a=x\\
b=y
$$
Mientras que el lado <strong>adyacente</strong> es equivalente al escalar \(r\) del vector, tal como:
$$
||\vec{r}|| = c = r
$$
si,
$$
c^2 = a^2+b^2 \\
\Rightarrow \sqrt{c^2} = \sqrt{a^2+b^2}\\
\Rightarrow c = \sqrt{a^2+b^2}
$$</p>
<p>Igualamos entonces los términos con las componentes del punto \(p\), y obtenemos la siguiente igualdad,</p>
<p>$$
||\vec{r}||= \sqrt{x^2+y^2}
$$
Para obtener el <strong>ángulo polar</strong> despejamos cualquiera de las primeras ecuaciones, a tal modo que el ángulo queda representado por su forma <strong>tangencial</strong> como:
$$
\frac{y}{x} = \tan{\theta}\\
\Rightarrow \theta = \tan^{-1}{(\frac{y}{x})} = \arctan{(\frac{y}{x})}\\
\Rightarrow \theta = \arctan{(\frac{y}{x})}
$$</p>
<blockquote>
<p><strong>Nota</strong>: De acuerdo al apartado <strong>Dominio del ángulo a través de la función tangente</strong> el ángulo \(\theta\) debe cumplír con ciertas condiciones, principalmente porque en el momento de computar esta operación pueden ocurrir errores o simplemente no obtener el resultado esperado, por lo tanto, para las siguientes definiciones asumiremos <em>cada vez que se calcule algún ángulo con respecto de su función <strong>tangente</strong> o <strong>inversa</strong> que será relativamente certera</em>. </p>
</blockquote>
<p>despejando la expresión de conversión para obtener las <strong>coordenadas polares</strong> con respecto a <strong>coordenadas cartesianas</strong> es,
$$
\vec{r} = \cases{
r = \sqrt{x^2+y^2}\\
\theta = \arctan{(\frac{y}{x})}
}
$$</p>
<p>Por tanto, conseguir el sistema de conversion de un sistema de <strong>coordenadas polares</strong> a <strong>coordenadas rectangulares</strong> se refleja como,
$$
p = \cases{
x = r *\cos{\theta}\\
y = r *\sin{\theta}
}
$$</p>
<h2 id="sistemas-tridimensiones"><a class="header" href="#sistemas-tridimensiones">Sistemas Tridimensiones.</a></h2>
<h3 id="coordenadas-cartesianas-cilíndricas"><a class="header" href="#coordenadas-cartesianas-cilíndricas">Coordenadas Cartesianas-Cilíndricas.</a></h3>
<p>Supongase una <strong>coordenada cartesiana</strong> dada por el punto \(p\) en el espacio por las componentes \((x,y,z)\) y el vector \(\vec{r}\) sean sus componentes \((r, \theta, z)\) dado por las <strong>coordenadas cilíndricas</strong>, donde el componente perpendicular común sea \(z\), la expresión de conversión de <strong>coordenadas cilíndricas</strong> respecto de los ejes en las <strong>coordenadas cartesianas</strong> es,
$$
\vec{r} = \cases{
r = \sqrt{x^2+y^2}\\
\theta = \arctan{ (\frac{x}{y}) }\\
z = z
}<br />
$$
Y viseversa, de <strong>coordenadas cilíndricas</strong> a <strong>rectangulares</strong> es,
$$
p = \cases{
x = r *\cos{\theta}\\
y = r *\sin{\theta}\\
z = z
}
$$</p>
<h3 id="coordenadas-cartesianas-esféricas"><a class="header" href="#coordenadas-cartesianas-esféricas">Coordenadas Cartesianas-Esféricas.</a></h3>
<p>Sea el punto <strong>cartesiano</strong> \(p_{cartesiana}\) por sus componentes \((x,y,z)\) y un punto \(p_{esférica}\) <strong>esférico</strong> regido por sus componentes \( (\rho, \phi, \theta) \), tal que \(\rho\) es el factor adyacente en los tres ejes \((x,y,z)\), seguido por las siguientes expresiones, 
$$
x = \rho \sin{\phi} \cos{\theta}\\
y = \rho \sin{\phi} \sin{\theta}\\
z = \rho \cos{\phi}
$$
La primer ecuación de acuerdo con el teorema de pitagoras para un modelo \(\mathbb{R}^3\) consta de,
$$
\rho = \sqrt{ x^2 + y^2 + z^2}
$$</p>
<p>Para obtener a \(\phi\) simplemente despejando a \(z\),
$$
\cos{\phi} = \frac{z}{\rho} = \frac{z}{\sqrt{ x^2 + y^2 + z^2}}\\
\Rightarrow \phi = \arccos{ (\frac{z}{\sqrt{ x^2 + y^2 + z^2}}) }
$$
Para la componenete \(\theta\) de igual manera podemos a partir de la relación que existe entre \(x\) y \(y\) tomar la siguiente ecuación,
$$
\theta = \arctan{ (\frac{x}{y}) }
$$
Entonces, la forma de expresar <strong>coordenadas esféricas</strong> mediante su forma <strong>rectangular</strong> es,
$$
p_{esférica} = \cases{
\rho = \sqrt{ x^2 + y^2 + z^2}\\
\phi = \arccos{ (\frac{z}{\sqrt{ x^2 + y^2 + z^2}}) }\\
\theta = \arctan{ (\frac{x}{y}) }
}
$$
Mientras que, para expresar <strong>coordenadas cartesianas</strong> mediante su forma <strong>esférica</strong> se define como,
$$
p_{cartesiana} = \cases{
x = \rho \sin{\phi} \cos{\theta}\\
y = \rho \sin{\phi} \sin{\theta}\\
z = \rho \cos{\phi}
}
$$</p>
<h3 id="coordenadas-cilíndricas-esféricas"><a class="header" href="#coordenadas-cilíndricas-esféricas">Coordenadas Cilíndricas-Esféricas.</a></h3>
<p>El sistema de <strong>coordenadas cilíndricas</strong> es un vector \(\vec{r}\) cuyas componenetes son \((r, \theta, z)\) y las <strong>coordenadas esféricas</strong> cuyo punto \(p_{esférica}\) descrita por las componentes \((\rho, \phi, \theta)\) comparten el ángulo de similitud \(\theta\) partiendo del sistema <strong>cartesiano</strong> expresado por:
$$
z = \rho \cos{\phi}
$$
si, 
$$
r = \sqrt{ x^2 + y^2 }
$$
y
$$
\rho = \sqrt{ x^2 + y^2 + z^2}
$$
Entonces despejando ambas ecuaciones,
$$
\rho^2 - z^2 = x^2 + y^2\\
\Rightarrow \rho^2 - z^2 = r^2\\
\Rightarrow r = \sqrt{ \rho^2 - z^2 }\\
\therefore  r = \sqrt{ \rho^2 - ( \rho \cos{\phi} )^2 } 
$$
Por consiguiente las <strong>cordenadas cilíndricas</strong> quedan expresadas en términos de <strong>coordenadas esféricas</strong> de la siguiente forma:
$$
\vec{r} = \cases{
r = \sqrt{ \rho^2 - ( \rho \cos{\phi} )^2 }\\
\theta = \theta\\
z = \rho \cos{\phi}
}
$$</p>
<p>Las <strong>coordenadas esféricas</strong> quedan expresadas en términos de <strong>coordenadas cilíndricas</strong>,
$$
p_{esférica} = \cases{
\rho = \sqrt{ r^2 + z^2 } \\
\phi = \arccos{ (\frac{z}{\sqrt{ r^2 + z^2}}) } \\
\theta = \theta
}
$$</p>
<!-- ## Sistemas Mixtos.
Como mencioné al principio de este capítulo, traspasar un sistema \\(\mathbb{R}^3\\) a uno de \\(\mathbb{R}^2\\) puede no ser conveniente debido a la pérdida de información que este conlleva, sin embargo es posible descomponer un sistema de tres diemensiones en sistemas más simples. Está sección tiene el propósito de explicar como hacer esta conversión de sistemas.

### Sistemas de \\(\mathbb{R}^2\\) a \\(\mathbb{R}^3\\).
#### Cartesiano \\(\mathbb{R}^2\\) - \\(\mathbb{R}^3\\)
Suponga un punto \\(p_{2}(x,y)\\) donde para cada punto se tiene,
$$
    x = a\\\\
    y = b\\\\
$$
sean \\(a\\) y \\(b\\) cualquier valor perteneciente a los \\(\mathbb{R}\\).
Para un sistema de 3 dimensiones consideraremos que \\(z\\) se inicializa en el origen es decir, \\(0\\).

$$
    p_{3} = \cases{
        x = a\\\\
        y = b\\\\
        z = 0
    }
$$

#### Cartesiano \\(\mathbb{R}^2\\) - Cilíndrico.
Considerese un punto \\(p_2\\) descrito por \\((x,y)\\) representado en coordenadas cilíndricas por el vector \\( \vec{r}(r, \theta, z) \\):
$$
    \vec{r} = \cases{
        r = \sqrt{x^2 + y^2}\\\\
        \theta = \cos{(\frac{ \sqrt{x^2+y^2} }{x})}\\\\
        z = 0
    }
$$

#### Cartesiano \\(\mathbb{R}^2\\) - Esférico.
Sea \\(p_2(x,y)\\) en términos esféricos de \\( p_{esférica}(\rho, \phi, \theta)\\), de acuerdo al caso cartesiano en que \\(z=0\\), obtenemos lo siguiente:
$$
    \rho = \sqrt{ x^2 + y^2 + (0)^2}\\\\
    \phi = 0\\\\
    \theta = \cos{(\frac{ \sqrt{x^2+y^2} }{x})}
$$
Simplificando,
$$
    \rho = \sqrt{ x^2 + y^2}\\\\
    \phi = 0\\\\
    \theta = \cos{( 
        \frac{ \sqrt{ x^2 + y^2} }{x} 
    )}
$$
Por tanto,
$$
    p_{esférico } = \cases{
        \rho = \sqrt{ x^2 + y^2}\\\\
        \phi = 0\\\\
        \theta = \cos{( 
            \frac{ \sqrt{ x^2 + y^2} }{x} 
        )}
    }
$$

#### Sistema Polar a Cartesiano \\(\mathbb{R}^3\\)
Suponga el caso de la coordenada polar \\(\vec{r}(r, \theta)\\) hacia un sistema cartesiano en el espacio


### Sistemas de \\(\mathbb{R}^3\\) a \\(\mathbb{R}^2\\) sin sufrir pérdidas de información. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="algoritmo"><a class="header" href="#algoritmo">Algoritmo</a></h1>
<p>En esta sección se describirá mediante una serie de algoritmos como podemos implementar los sistemas de conversiones de coordenadas espaciales. Primero aplicaremos un algoritmo para el <strong>dominio del ángulo a través de la función tangente</strong> que repasamos en la sección anteriór. El formato de los algorítmos será en pseudocódigo </p>
<h2 id="cálculo-del-ángulo-mediante-la-función-tangente"><a class="header" href="#cálculo-del-ángulo-mediante-la-función-tangente">Cálculo del ángulo mediante la función tangente.</a></h2>
<pre><code class="language-S">FROM mathematical MODULE IMPORT FUNCTION atan;

START_FUNCTION getAngle( opposite, adjacent ) -&gt; FLOAT:
    FLOAT opposite &lt;- opposite;
    FLOAT adjacent &lt;- adjacent;
    FLOAT angle    &lt;-      0.0;
    IF adjacent == 0.0 THEN:
        IF opposite != 0.0 THEN:
            IF opposite &lt; 0.0 THEN:
                angle &lt;- 270.0;
            ELSE:
                angle &lt;- 90.0;
            END_IF
        END_IF
    ELSE:
        angle &lt;- atan( opposite / adjacent );
        IF opposite &lt; 0.0 THEN:
            IF adjacent &lt; 0.0 THEN:
                angle &lt;- 270.0 - angle;
            ELSE:
                angle &lt;- 360.0 + angle;
            END_IF
        ELSE:
            IF adjacent &lt; 0.0 THEN:
                angle &lt;- 180.0 + angle;
            ELSE:
                angle &lt;- angle;
            END_IF
        END_IF
    END_IF

    RETURN angle;
END_FUNCTION
</code></pre>
<h2 id="coordenadas-cartesianas-cilíndricas-1"><a class="header" href="#coordenadas-cartesianas-cilíndricas-1">Coordenadas Cartesianas-Cilíndricas.</a></h2>
<pre><code class="language-S">IMPORT FUNCTION getAngle;

START_FUNCTION cartesian3dToCylindrical( x, y, z ) -&gt; DICTIONARY:
    FLOAT x &lt;- x;  
    FLOAT y &lt;- y;
    FLOAT z &lt;- z;

    FLOAT radio &lt;- ( x^2 + y^2 )^(1/2);
    FLOAT theta &lt;- getAngle( y, x );
    RETURN START_DICTIONARY:
        &quot;radio&quot; &lt;- radio;
        &quot;theta&quot; &lt;- theta; 
        &quot;z&quot;     &lt;-     z;
    END_DICTIONARY
END_FUNCTION
</code></pre>
<h2 id="coordenadas-cartesianas-esféricas-1"><a class="header" href="#coordenadas-cartesianas-esféricas-1">Coordenadas Cartesianas-Esféricas.</a></h2>
<pre><code class="language-S">IMPORT FUNCTION                 getAngle;
IMPORT FUNCTION cartesian3dToCylindrical;

START_FUNCTION cartesian3dToSpherical( x, y, z ) -&gt; DICTIONARY:
    DICTIONARY cylindrical &lt;- cartesian3dToCylindrical( x, y, z );
    FLOAT      rho         &lt;-         ( x^2 + y^2 + z^2 )^( 1/2 );
    FLOAT      phi         &lt;- getAngle( cylindrical[&quot;radio&quot;], z );
    FLOAT      theta       &lt;-                cylindrical[&quot;theta&quot;];

    RETURN START_DICTIONARY:
        &quot;rho&quot;   &lt;-   rho;
        &quot;theta&quot; &lt;- tehta;
        &quot;phi&quot;   &lt;-   phi;
    END_DICTIONARY
END_FUNCTION
</code></pre>
<h2 id="coordenadas-cilíndricas-cartesianas"><a class="header" href="#coordenadas-cilíndricas-cartesianas">Coordenadas Cilíndricas-Cartesianas</a></h2>
<pre><code class="language-S">FROM mathematical MODULE IMPORT FUNCTIONS cos, sin;

START_FUNCTION cylindricalToCartesian3d( radio, theta, z ) -&gt; DICTIONARY:
    FLOAT radio &lt;- radio;
    FLOAT theta &lt;- theta;
    FLOAT z     &lt;-     z;

    FLOAT x &lt;- radio * cos( theta );
    FLOAT y &lt;- radio * sin( theta );

    RETURN START_DICTIONARY:
        &quot;x&quot; &lt;- x;
        &quot;y&quot; &lt;- y;
        &quot;z&quot; &lt;- z;
    END_DICTIONARY
END_FUNCTION
</code></pre>
<h2 id="coordenadas-cilíndricas-esféricas-1"><a class="header" href="#coordenadas-cilíndricas-esféricas-1">Coordenadas Cilíndricas-Esféricas</a></h2>
<pre><code class="language-S">IMPORT FUNCTION cylindricalToSpherical3d;
IMPORT FUNCTION   cartesian3dToSpherical;

START_FUNCTION cylindricalToSpherical( radio, theta, z ) -&gt; DICTIONARY:
    FLOAT radio &lt;- radio; 
    FLOAT theta &lt;- theta;
    FLOAT z     &lt;-     z;

    DICTIONARY cartesian &lt;- cylindricalToCartesian3d( radio, theta, z );
    DICTIONARY spherical &lt;- cartesian3dToSphaerical ( cartesian[&quot;x&quot;], cartesian[&quot;y&quot;], cartesian[&quot;z&quot;] );

    RETURN START_DICTIONARY:
        &quot;rho&quot;   &lt;- spherical[&quot;rho&quot;  ];
        &quot;theta&quot; &lt;- spherical[&quot;theta&quot;];
        &quot;phi&quot;   &lt;- spherical[&quot;phi&quot;  ];
    END_DICTIONARY
END_FUNCTION

</code></pre>
<h2 id="coordenadas-esfpericas-cilíndricas"><a class="header" href="#coordenadas-esfpericas-cilíndricas">Coordenadas Esfpericas-Cilíndricas</a></h2>
<pre><code class="language-S">FROM mathematical MODULE IMPORT FUNCTIONS cos, sin;

START_FUNCION sphericalToCylindrical( rho, theta, phi ) -&gt; DICTIONARY:
    FLOAT rho   &lt;-   rho;
    FLOAT theta &lt;- theta;
    FLOAT phi   &lt;-   phi;

    IF rho &lt; 0.0 THEN:
        rho &lt;- rho * (-1);
    END_IF

    FLOAT radio &lt;- 0.0;
    FLOAT     z &lt;- 0.0;

    IF rho != 0 THEN:
        z     &lt;- rho * cos( phi );
        radio &lt;- rho * sin( phi );
    END_IF

    RETURN START_DICTIONARY:
        &quot;radio&quot; &lt;- radio;
        &quot;theta&quot; &lt;- theta;
        &quot;z&quot;     &lt;-     z;
    END_DICTIONARY
END_FUNCTION
</code></pre>
<h2 id="coordenadas-esféricas-cartesianas"><a class="header" href="#coordenadas-esféricas-cartesianas">Coordenadas Esféricas-Cartesianas</a></h2>
<pre><code class="language-S">IMPORT FUNCTION  sphaericalToCylindrical;
IMPORT FUNCTION cylindricalToCartesian3d;

START_FUNCTION sphericalToCartesian3d( rho, theta, phi ) -&gt; DICTIONARY:
    DICTIONARY cylindrical &lt;- sphericalToCylindrical( rho, theta, phi );
    DICTIONARY cartesian   &lt;- cylindricalToCartesian3d( cylindrical[&quot;radio&quot;], cylindrical[&quot;theta&quot;], cylindrical[&quot;z&quot;] );

    RETURN START_DICTIONARY:
        &quot;x&quot; &lt;- cartesian[&quot;x&quot;];
        &quot;y&quot; &lt;- cartesian[&quot;y&quot;];
        &quot;z&quot; &lt;- cartesian[&quot;z&quot;];
    END_DICTIONARY
END_FUNCTION
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementación-en-python"><a class="header" href="#implementación-en-python">Implementación en Python</a></h1>
<p>Para la implentación en <code>python</code> y siguiendo el procedimiento en el pseudocódigo se aplican de la siguiente forma:</p>
<p>Se crea una carpeta de preferencia con el nombre asociado a su proyecto que mejor le parezca y dentro se crea un archivo <code>spatial.py</code> que almacenará los módulos de conversión de coordenadas espaciales.</p>
<pre><code>project/
├── file_1
├── file_2
├── ...
├── file_n
└── space_modules/
    └── spatial.py
</code></pre>
<p>importe de la librería <code>math</code> los módulos <code>sin</code>, <code>cos</code>, <code>radians</code>, <code>degrees</code>, <code>atan</code></p>
<pre><code class="language-python">from math import sin. cos, atan, radians, degrees, radians
</code></pre>
<blockquote>
<p>Nota: las funciones trigonométricas que implementa python <strong>reciben solo argumentos en radianes</strong> por lo que cuando se calcula el ángulo devuelve el ángulo en radianes, por ese motivo se importa la función <code>degrees( radians )</code> que recibe un argumento en radianes y lo transforma en un ángulo angular.</p>
</blockquote>
<h2 id="módulo-dominio-del-ángulo-a-través-de-la-función-tangente"><a class="header" href="#módulo-dominio-del-ángulo-a-través-de-la-función-tangente">Módulo <strong>Dominio del ángulo a través de la función tangente</strong></a></h2>
<p>Se nombrará el módulo como <code>get_angle( apposite, adjacent )</code>, el cual recibe los argumentos <em>opuesto</em> y <em>adyacente</em> que retornará un valor flotante.</p>
<pre><code class="language-python">def get_angle( opposite=float(), adjacent=float() ) -&gt; float:
    angle = 0.0

    if adjacent == 0:
        if opposite != 0: angle = 270
        else            : angle =  90
    else: 
        angle = degrees( atan( opposite / adjacent ) )
        if opposite &lt; 0:
            if   adjacent &lt; 0: angle = 270 - angle
            else             : angle = 360 + angle
        else:
            if adjacent &lt; 0: angle = 180 + angle
            else           : angle =       angle
    return angle
</code></pre>
<h2 id="conversión-de-coordenadas-cartesianas-a-cilíndricas-y-esféricas"><a class="header" href="#conversión-de-coordenadas-cartesianas-a-cilíndricas-y-esféricas">Conversión de coordenadas Cartesianas a Cilíndricas y Esféricas</a></h2>
<ul>
<li>De Cartesianas Espaciales a Cilíndricas:</li>
</ul>
<pre><code class="language-python">def cartesian3d_to_cylindrical( x=float(), y=float(), z=float() ) -&gt; dict:
    radio = ( x**2 + y**2 + z**2 )**(1/2);
    theta = getAngle( y, x )

    return {
        &quot;radio&quot;:radio,
        &quot;theta&quot;:theta,
        &quot;z&quot;    : z
    }
</code></pre>
<ul>
<li>De Cartesianas Espaciales a Esféricas:</li>
</ul>
<pre><code class="language-python">def cartesian3d_to_spherical( x=float(), y=float(), z=float() ) -&gt; dict:
    cylindrical = cartesian3d_to_cylindrical( x, y, z )
    rho         =       ( x**2 + y**2 + z**2 )**(1/2)
    phi         = get_angle( cylindrical[&quot;radio&quot;], z )
    theta       =                cylindrical[&quot;theta&quot;]

    return {
        &quot;rho&quot;  :   rho,
        &quot;theta&quot;: theta,
        &quot;phi&quot;  :   phi,
    }
</code></pre>
<h2 id="conversión-de-coordenadas-cilíndricas-a-cartesianas-y-esféricas"><a class="header" href="#conversión-de-coordenadas-cilíndricas-a-cartesianas-y-esféricas">Conversión de Coordenadas Cilíndricas a Cartesianas y Esféricas</a></h2>
<ul>
<li>De Cilíndricas a Cartesianas Espaciales:</li>
</ul>
<pre><code class="language-python">def cylindrical_to_cartesian3d( radio=float(), theta=float(), z=float() ) -&gt; dict:
    theta_radians = radians( theta )
    x = radio * cos( theta_radians )
    y = radio * sin( theta_radians )

    return {
        &quot;x&quot;: x,
        &quot;y&quot;: y,
        &quot;z&quot;: z,
    }
</code></pre>
<ul>
<li>De Cilíndricas a Esféricas:</li>
</ul>
<pre><code class="language-python">def cylindrical_to_spherical( radio=float(), theta=float(), z=float() ) -&gt; dict:
    cartesian = cylindrical_to_cartesian3d( radio, theta, z )
    spherical = cartesian3d_to_spherical( 
        cartesian[&quot;x&quot;], 
        cartesian[&quot;y&quot;],
        cartesian[&quot;z&quot;],
    )

    return {
        &quot;rho&quot;  : spherical[&quot;rho&quot;  ],
        &quot;theta&quot;: spherical[&quot;theta&quot;],
        &quot;phi&quot;  : spherical[&quot;phi&quot;  ],
    }
</code></pre>
<h2 id="conversión-de-coordenadas-esféricas-a-cartesianas-y-cilíndricas"><a class="header" href="#conversión-de-coordenadas-esféricas-a-cartesianas-y-cilíndricas">Conversión de Coordenadas Esféricas a Cartesianas y Cilíndricas</a></h2>
<p>-De Esféricas a Cilíndricas:</p>
<pre><code class="language-python">def spherical_to_cylindrical( rho=float(), theta=float(), phi=float() ) -&gt; dict:
    if rho &lt; 0:
        rho = rho * (-1)
    radio = 0
    z     = 0

    if rho != 0:
        phi_radians = radians( phi )
        z     = rho * cos( phi_radians )
        radio = rho * sin( phi_radians )

    return {
        &quot;radio&quot;: radio,
        &quot;theta&quot;: theta,
        &quot;z&quot;    :     z,
    }
</code></pre>
<p>-De Esféricas a Cartesianas:</p>
<pre><code class="language-python">def spherical_to_cartesian3d( rho=float(), theta=float(), phi=float() ) -&gt; dict: 
    cylindrical = spherical_to_cylindrical( rho, theta, phi )
    cartesian   = cylindrical_to_cartesian3d(  
        cylindrical[&quot;radio&quot;],
        cylindrical[&quot;theta&quot;],
        cylindrical[&quot;z&quot;    ],
    )
    return {
        &quot;x&quot;: cartesian[&quot;x&quot;],
        &quot;y&quot;: cartesian[&quot;y&quot;],
        &quot;z&quot;: cartesian[&quot;z&quot;],
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementación-en-javascript"><a class="header" href="#implementación-en-javascript">Implementación en JavaScript</a></h1>
<p>Para la implementación en <code>JavaScript</code> de acuerdo al Pseudocódigo se estructurará en un proyecto con las cualidades con las que se adapta al diseño de un sitio web, por lo que el aŕbol de archivos principal del proyecto es el del proyecto al cual podemos denominar <code>website</code>, dentro de ella puede existir el archivo <code>index.html</code> en la carpeta principal, subcarpetas para estilos <code>/css</code> y finalmente donde se albergará nuestro archivo <code>spatial.js</code> con los módulos, la carpeta <code>/js</code>, esta estructura de proyecto es solo una sugerencia, aunque usted puede implementarla como se le de la gana,</p>
<pre><code>website/
├── index.html
├── css/
├   └── style.css
└── js/
    ├── main.js
    └── spatial.js
</code></pre>
<h2 id="validación-de-números"><a class="header" href="#validación-de-números">Validación de números</a></h2>
<p>La validación para convertir un valor a tipo flotante se debe principalmente a que pueden llegar solicitudes a las funciones con valores que no exactamente son valores numéricos, sino que llegan los valores como una cadena de texto que tiene que interpretar nuestro programa</p>
<pre><code class="language-js">function validateNumbers(a,b,c){
    a = parseFloat( a );
    b = parseFloat( b );
    c = parseFloat( c );
    if( isNaN( a ) ){ a=0; }
    if( isNaN( b ) ){ b=0; }
    if( isNaN( c ) ){ c=0; }

    return { a, b, c };
}
</code></pre>
<h2 id="conversión-de-radianes-a-grados-y-grados-a-radianes"><a class="header" href="#conversión-de-radianes-a-grados-y-grados-a-radianes">Conversión de Radianes a Grados y Grados a Radianes</a></h2>
<p>Si bien ya no es necesario importar modulos para <code>sin</code> o <code>cos</code>, es necesario hacer las conversiones de radianes a grados y viceversa, principalmente porque no he encontrado un método nativo dentro de las funcionalidades de <code>JS</code>.</p>
<pre><code class="language-js">function radiansToAngle( radians=0 ){
    return radians * ( 180 / Math.PI );
}
</code></pre>
<pre><code class="language-js">function angleToRadians( angle=0 ){
    return angle * Math.PI / 180;
}
</code></pre>
<h2 id="mófulo-dominio-del-ángulo-a-través-de-la-función-tangente"><a class="header" href="#mófulo-dominio-del-ángulo-a-través-de-la-función-tangente">Mófulo <strong>Dominio del ángulo a través de la función tangente</strong></a></h2>
<pre><code class="language-js">function getAngle( opposite=0, adjacent=0 ){
    let angle = 0;
    if( adjacent == 0 ){
        if( opposite != 0 ){
            if( opposite &lt; 0 ){ angle = 270 }
            else{ angle = 90; }
        }
    }else{
        angle = radiansToAngle( Math.atan( opposite/adjacent ) );
        if(opposite &lt; 0 ){
            if( adjacent &lt; 0 ){ angle = 270 - angle;}
            else{ angle = 360+angle; }
        }else{
            if( adjacent &lt; 0 ){ angle = 180 + angle;}
            else{ angle = angle; }
        }
    }

    return angle;
}
</code></pre>
<h2 id="conversión-de-coordenadas-cartesianas-a-cilíndricas-y-esféricas-1"><a class="header" href="#conversión-de-coordenadas-cartesianas-a-cilíndricas-y-esféricas-1">Conversión de Coordenadas Cartesianas a Cilíndricas y Esféricas</a></h2>
<pre><code class="language-js">function cartesian3dToCylindrical( x=0, y=0, z=0 ){
    let numbers = validateNumbers( x, y, z );
    x = numbers.a; 
    y = numbers.b; 
    z = numbers.c;

    let radio = ( x**2 + y**2 )**(1/2);
    let theta = getAngle( y, x );
    return { radio: radio, theta: theta, z: z };
}
</code></pre>
<pre><code class="language-js">function cartesia3dToSpherical( x=0, y=0, z=0 ){
    let cylindrical = cartesian3dToCylindrical(x, y, z );
    let rho   = (x**2 + y**2 + z**2)**(1/2);
    let phi   = getAngle( cylindrical.radio, z );
    // console.log( &quot;phi&quot;+phi );
    let theta = cylindrical.theta;
    
    return { rho, theta, phi };
}
</code></pre>
<h2 id="coversión-de-coordenadas-cilíndricas-a-cartesianas-y-esféricas"><a class="header" href="#coversión-de-coordenadas-cilíndricas-a-cartesianas-y-esféricas">Coversión de Coordenadas Cilíndricas a Cartesianas y Esféricas</a></h2>
<pre><code class="language-js">function cylindricalToCartesian3d( radio, theta, z ){
    let numbers = validateNumbers( radio, theta, z );
    radio = numbers.a;
    theta = numbers.b;
    z     = numbers.c;

    let theta_rad = angleToRadians( theta ); 
    let x = radio * Math.cos( theta_rad );
    let y = radio * Math.sin( theta_rad );

    return { x, y, z };
}
</code></pre>
<pre><code class="language-js">function cylindricalToSpherical( radio, theta, z ){
    let numbers = validateNumbers( radio, theta, z );
    radio = numbers.a;
    theta = numbers.b;
    z     = numbers.c;
    let cartesian = cylindricalToCartesian3d( radio, theta, z );
    let spherical = cartesia3dToSpherical   ( cartesian.x, cartesian.y, cartesian.z );

    return { 
        rho  : spherical.rho  ,
        theta: spherical.theta,
        phi  : spherical.phi  ,
    }
}
</code></pre>
<h2 id="conversión-de-coordenadas-esféricas-a-cartesianas-y-cilíndricas-1"><a class="header" href="#conversión-de-coordenadas-esféricas-a-cartesianas-y-cilíndricas-1">Conversión de Coordenadas Esféricas a Cartesianas y Cilíndricas</a></h2>
<pre><code class="language-js">function sphericalToCylindrical( rho=0, theta=0, phi=0 ){
    let numbers = validateNumbers(rho, theta, phi);
    rho   = numbers.a;
    theta = numbers.b;
    phi   = numbers.c;
    if( rho &lt; 0 ){ rho = rho*(-1); }


    // console.log( {rho, phi, theta} );
    let radio = 0;
    let z     = 0;
    if(  rho != 0  ){
        let phiRad = angleToRadians( phi );
        z     = rho * Math.cos( phiRad );
        radio = rho * Math.sin( phiRad );
        console.log( `${z}* tan(${phi})` );
    }

    return { radio, theta, z  };
}
</code></pre>
<pre><code class="language-js">function sphericalToCartesian3d( rho=0, theta=0, phi=0 ){
    let cylindrical = sphericalToCylindrical( rho, theta, phi );
    let cartesian   = cylindricalToCartesian3d( cylindrical.radio, cylindrical.theta, cylindrical.z );
    return { x: cartesian.x, y: cartesian.y, z: cartesian.z };
}
</code></pre>
<p>El miniproyecto con interfaz en navegador lo puede encontrar en <a href="https://luisalvarado3.github.io/spatial_coordinate_converter/">Conversor de coordenadas espaciales</a> con el cual ocupé los modulos mostrados en esta guía.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capítulo-2"><a class="header" href="#capítulo-2">Capítulo 2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traslación"><a class="header" href="#traslación">Traslación</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capítulo-3"><a class="header" href="#capítulo-3">Capítulo 3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rotación"><a class="header" href="#rotación">Rotación</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
